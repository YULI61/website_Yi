<!DOCTYPE html>
<html>
<head>
       
  <title>London Attraction Map</title>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.css" rel="stylesheet">
  <link rel="icon" href="data:,">

  
    
<style>
        
    html, body {
        margin: 0 !important;
        padding: 0 !important;
        overflow: hidden !important; 
        background-color: black !important; 
        overflow: hidden；
        font-size: 16px;
    }
    
    @media (max-width: 768px) {
        html {
            font-size: 14px;
        }
    }

    @media (max-width: 480px) {
        html {
            font-size: 12px;
        }
    }
   
    
    #title {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #FFD700;  
      font-size: 2.5em;
      font-family: 'Arial Black', sans-serif;
      z-index: 1000;
      padding: 10px 20px;
      max-width: 90%;
      text-shadow: 
        0 0 2px #fff,
        0 0 2px rgba(255,255,255,0.5); 
      
      -webkit-text-stroke: 1px rgba(255,255,255,0);
      paint-order: stroke fill;
    }

    @media (max-width: 768px) {
      #title {
        font-size: 1.8em;
        -webkit-text-stroke: 0.8px rgba(255,255,255,0.9);
        text-shadow: 
          0 0 1px #fff,
          0 0 6px rgba(255,255,255,0.4);
        font-size: 1.5rem;
        top: 1vh;
      }
    }
 
    
    #data-source {
      position: fixed;
      top: 80px;
      left: 26px;
      color: rgba(255,255,255,0.8);
      font-size: 0.7em;
      font-family: Arial;
      z-index: 1000;
      background: rgba(0,0,0,0);
      padding: 5px 10px;
      border-radius: 5px;
        
      width: auto; 
      max-width: 550px; 
      white-space: normal; 
      display: inline-block; 
      padding: 8px 15px; 
    }

    @media (max-width: 768px) {
      #data-source {
        left: 50%;
        transform: translateX(-50%);
        width: 90vw; 
        max-width: none;
        text-align: center;
        box-sizing: border-box;
      }        
    }    

    
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;    
      height: 100vh;
    }

    
/* Left Side Filter */
    .filter-panel {
      position: fixed;
      left: -220px;
      top: 220px;
      width: 200px;
      background: rgba(255,255,255,0.9);
      border-radius: 0 0px 0px 0;
      transition: all 0.3s ease;
      box-shadow: 3px 0 15px rgba(0,0,0,0.3);
      z-index: 1000;
      padding: 10px;
    }

    .filter-panel.expanded {
      left: 0;
    }

    .panel-toggle-button {
      position: absolute;
      right: -30px;
      top: 0;
      width: 30px;
      height: 100%;
      background: rgba(255,255,255,0.7);
      border-radius: 0 10px 10px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      font-size: 2em;
      border: none;
    }

    .filter-option {
      padding: 12px;
      color: #333;
      cursor: pointer;
      border-radius: 5px;
      display: flex;
      align-items: center;
      transition: all 0.2s;
      margin: 5px 0;
      font-size: 15px;
      background: rgba(255,255,255,0.8);
    }

    .filter-option:hover {
      background: rgba(255,215,0,0.3);
    }

    .filter-option.active {
      background: rgba(255,215,0,0.4);
      box-shadow: 0 0 8px rgba(255,215,0,0.3);
    }

    .cluster-mode .filter-panel {
        display: none !important;
    }    
   
    .color-dot {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 10px;
      border: 0.5px solid #666;
    }
    
    @media (max-width: 768px) {
      .filter-panel {
        top: 140px;
        width: 180px;
      }

      .filter-option {
        padding: 12px 16px;
        font-size: 15px;
        margin: 6px 10px;
      }
    }    
    

/*bar chart*/
    .chart-container {
      width: 100%;  
      padding: 10px; 
      box-sizing: border-box; 
      display: none; 
    }

    #miniChart {
      width: 100% !important;
      height: 200px !important; 
}
 
    
/*mapboxgl-ctrl*/        
    .mapboxgl-ctrl.mapboxgl-ctrl-group {
      border-radius: 10px !important;
      transform: scale(1.1) translateZ(0) !important;  
      transform-origin: top right !important;         
      margin: 20px 25px !important;
    }

    .mapboxgl-ctrl-group button {
      width: 36px !important;
      height: 35px !important;
      padding: 10px !important;
    }

    .mapboxgl-ctrl-icon {
      background-size: 28px 28px !important;
      image-rendering: -webkit-optimize-contrast;    
    }
 
    
    
/* Mode switch style */
    .toggle-container {
      position: absolute;
      top: 40px;
      right: 30px;
      z-index: 1500;
      display: flex;
      gap: 12px; 
      padding: 12px; 
      border-radius: 16px; 
    }

    .mode-toggle-button {
      padding: 8px 24px; 
      min-width: 10px; 
      border: none;
      border-radius: 10px; 
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      font-size: 1.1em; 
      line-height: 1.2; 
      cursor: pointer;
      transition: all 0.3s ease;
      background: rgba(255, 215, 0, 0.1);
      color: rgba(255, 215, 0, 0.8);
      position: relative;
      overflow: hidden;
    }

    @media (max-width: 768px) {
      .toggle-container {
        gap: 8px;
        padding: 8px;
      }

      .mode-toggle-button {
        padding: 8px 12px;
        min-width: 90px;
        font-size: 0.8em;
      }
    }

    .mode-toggle-button.active {
      background: linear-gradient(145deg, #FFD700 30%, #FFA500 100%);
      color: #000;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
      border: 1px solid rgba(255, 215, 0, 0.5);
    }

    .mode-toggle-button:hover:not(.active) {
      background: rgba(255, 215, 0, 0.2);
      color: #FFD700;
      transform: translateY(-1px);
    }

    .mode-toggle-button:active {
      transform: scale(0.98);
    }

    .mode-toggle-button.active::after {
      opacity: 1;
    }
    
    
 /* legend in area mode */   
    #legend {
      position: fixed;
      bottom: 35px;
      right: 80px;
      background: rgba(255,255,255,1);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
    }

    .legend-gradient {
      width: 160px;
      height: 18px;
      background: linear-gradient(to right, 
          #1a1a1a 0%,    
          #F8F2DE 20%,   
          #ECDCBF 40%,   
          #A31D1D 60%,   
          #D84040 80%, 
          #ffff99 100%  
      );
      margin-bottom: 5px;
      margin-top: 8px;
    }


    .legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8em;
    }

    .legend-pointer {
      position: absolute;
      top: -1px;
      font-size: 13px;
      transform: translateX(-50%);
      transition: left 0.2s ease;
    }   
    
    
/* cluster mode */
    #clusterControl {
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 15px;
      white-space: nowrap;
    }

    #clusterControl select {
      background: rgba(0,0,0,0.7);
      color: #FFD700;
      border: 1px solid #FFD700;
      border-radius: 4px;
      padding: 2px 5px;
    }    
        
    #cluster-id-container {
        display: flex;
        flex-wrap: wrap;
        flex-direction: column;
        position: fixed;
        top: 80px;
        left: 20px;
        max-height: 400px; 
        overflow-y: auto;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 5px;
        border-radius: 5px;
        z-index: 9999;
    }

    .cluster-id-btn {
        display: block;
        background: rgba(255, 215, 0, 0.2);
        color: #FFD700;
        border: none;
        padding: 5px;
        font-size: 0.8em;
        cursor: pointer;
        border-radius: 3px;
        margin-bottom: 2px;
        transition: all 0.3s;
    }

    .cluster-id-btn.active {
        background: #FFD700;
        color: black;
    }

  
    #clusterControl, #clusterFilterControl {
      color: #FFD700;
    }

    #clusterSelector {
      background: rgba(0,0,0,0.8);
      color: #FFD700;
      border: px solid #FFD700;
      padding: 2px 10px;
    } 
    

/* style of slider */
    .custom-slider {
      -webkit-appearance: none;
      width: 300px;
      height: 6px;
      background: rgba(255,215,0,0.3);
      border-radius: 3px;
      outline: none;
    }

    .custom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #FFD700;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .custom-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #FFD700;
      border-radius: 50%;
      cursor: pointer;
    }

    .custom-slider:hover::-webkit-slider-thumb {
      transform: scale(1.2);
    }

    .slider-ticks {
      display: flex;
      gap: 50px;  
      width: auto;
      margin-top: 5px;
      text-align: center;
        
    }

    .slider-tick {
      color: #FFD700;
      font-size: 0.8em;
    }  

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }   
       
    @media (max-width: 480px) {
      #clusterControlsContainer {
        left: 10px;
        right: 10px;
        width: calc(100% - 20px);
        max-width: 300px;
      }
      #clusterDescription {
        font-size: 0.7em;
      }
    }    

    #clusterControlsContainer {
        background: rgba(0, 0, 0, 0.9);
        color: #FFD700;
        padding: 12px;
        border-radius: 8px;
        width: 380px; 
        max-width: 90%; 
        font-family: Arial, sans-serif;
    }

    .slider-container input {
        width: 100%;
    }


/* intro text */    
    @keyframes countUp {
      from { transform: translateY(20px); opacity: 0; }
      20% { opacity: 1; transform: translateY(0); }
      to { 
        content: '1121';
        transform: scale(1.05);
        text-shadow: 0 0 12px rgba(255,215,0,0.4);
      }
    }

    @keyframes fadeInUp {
      from { 
        opacity: 0;
        transform: translateY(15px);
      }
      to { 
        opacity: 0.9;
        transform: translateY(0);
      }
    }    
        
  </style>
</head>

    
    
<body>
    
    <div id="splash-overlay" 
         style="position: fixed; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 99999; transition: opacity 0.5s;">
        
        <div id="splash-text" 
             style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                    color: #FFD700; text-align: center; font-family: 'Arial Black', sans-serif; opacity: 0.9;font-size: 1.8em; 
                    animation: fadeIn 0.8s 0.3s forwards;">
          <div class="line" style="overflow: hidden;">
            <span id="counter" style="display: inline-block; font-size: 2em; 
                   animation: countUp 2.5s ease-out forwards;">0</span> 
            ATTRACTIONS AWAIT
          </div>
          <div class="line" style="opacity: 0; margin-top: 0.8em; font-size: 0.6em;font-family: 'Arial';color: #FFFFFF;
                   animation: fadeInUp 1s 2.5s forwards;">
            Tap anywhere to explore London's view
          </div>
        </div>        
    </div>           
   
    <div id="clusterControlsContainer" 
         style="display:none; position: fixed; top: 130px; left: 30px; z-index: 1001; background: rgba(0,0,0,0.7); padding: 8px; border-radius: 8px; flex-direction: column; gap: 8px;">
    
      <p style="
          font-size: 15px; 
          font-weight: bold; 
          color: #F8F2DE; 
          margin: 10px;
          line-height: 1.8;">
         <span style="color: #FFD700;">DBSCAN Clustering</span> <br>
        Adjust the neighborhood radius (eps) to control clustering scale.
      </p>        
               
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <div class="slider-container">
          <input type="range" 
                 id="epsSlider" 
                 min="300" 
                 max="1500" 
                 step="300"
                 value="300"
                 class="custom-slider">
        </div>
            <div id="clusterDescription" 
                 style="
                      font-size: 15px; 
                      font-weight: bold; 
                      color: #F8F2DE; 
                      margin: 10px;
                      line-height: 1.8;">
            </div>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <span id="clusterFilterControl" style="font-size:1em;">
          Show:
        </span>
        <select id="clusterSelector" style="flex-grow: 1;">
          <option value="all">All Points</option>
          <option value="unclustered">Unclustered Points</option>
        </select>
      </div>
        
      <p style="
          font-size: 12px; 
          color: #F8F2DE; 
          line-height: 1.4;
          background: rgba(255, 255, 255, 0.05);
          border-radius: 4px;
          margin: 10px;">
        Use the filter or click points to explore attraction groups.
      </p>        

    </div>  
   
    
    <div id="title">
      London Attractions Map 
    </div>    
    
    
    <div id="data-source">
        Data Source: 
        <a href="https://wiki.openstreetmap.org/wiki/Overpass_API" target="_blank" style="color:#FFD700; text-decoration:none;">
            Overpass API
        </a> & OpenStreetMap Contributors |
        Processed by Custom Data Pipeline | Updated: Nov 2024
    </div>
       
    
    <div id="map"></div> 
    
    <div id="legend">
      <div class="legend-gradient"></div>
      <div class="legend-labels">
        <span>0</span>
        <span>Average</span>
        <span>Max</span>
      </div>
      <div class="legend-pointer">▼</div>
    </div>

    <div class="toggle-container">
      <button class="mode-toggle-button active" id="pointMode">Point</button>
      <button class="mode-toggle-button" id="areaMode">Area</button>
      <button class="mode-toggle-button" id="clusterMode">Clustering</button> 
    </div>
    
    <div class="filter-panel"> 
      <button class="panel-toggle-button">«</button>
      <div class="filter-content">
        <div class="filter-option active" data-type="all">
          <div class="color-dot" style="background: #FFFFFF"></div>
          All Types
        </div>
      </div>      
      <div class="chart-container">
        <canvas id="miniChart"></canvas>
      </div>             
    </div>

    <div class="chart-container">
        <canvas id="miniChart"></canvas>
    </div>


    
    
  <script>
         
    mapboxgl.accessToken = 'pk.eyJ1IjoieWwzIiwiYSI6ImNtN2txZGc2czAzYjMybXNka3ZsbTl5cmQifQ.kV4cU6Id_aGZM7R1HiudwA';
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/dark-v11',
      center: [-0.1278, 51.5074],
      zoom: 9.8, 
    });
      
    
    let mode = "point"; 
    let boroughStatsData = null; 
    let currentEPS = 300;
          
     fetch('https://raw.githubusercontent.com/YULI61/visual_personal/main/borough_stats.json')
            .then(r => r.json())
            .then(data => boroughStatsData = data)
            .catch(console.error);      

      
 
// intro design
    document.addEventListener('click', function hideSplash() {
      const overlay = document.getElementById('splash-overlay');
      const text = document.getElementById('splash-text');

      overlay.style.opacity = '0';
      text.style.opacity = '0';

      setTimeout(() => {
        overlay.remove();
        text.remove();
      }, 500); 

      document.removeEventListener('click', hideSplash);
    }, { once: true });   
      
    document.addEventListener('DOMContentLoaded', () => {
      const counter = document.getElementById('counter');
      let current = 0;
      const target = 1121;
      const duration = 1500;

      const animate = () => {
        const start = Date.now();

        const update = () => {
          const elapsed = Date.now() - start;
          const progress = Math.min(elapsed / duration, 1);
          current = Math.floor(progress * target);

          counter.textContent = current.toLocaleString();

          if (progress < 1) requestAnimationFrame(update);
          else counter.textContent = target.toLocaleString();
        };

        requestAnimationFrame(update);
      };

      setTimeout(animate, 500);
    });
      
      
    const filterPanel = document.querySelector('.filter-panel');

      
// Category Colour Configuration
    const categoryColors = {
      museum: '#D62828',   
      gallery: '#FF8800',  
      attraction: '#F35D05', 
      park: '#4CAF50',     
      amenity: '#FFC300',  
      historic: '#2978B5', 
      other: '#8F5E1E'     
    };

    
// Add navigation controls
    map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
      

    function getBoroughStats(type) {
        if (!boroughStatsData) return [];

        return Object.entries(boroughStatsData.boroughs).map(([name, data]) => ({
            name: name.replace("London Borough of ", "") 
                      .replace("Royal Borough of ", "")
                      .replace("City of ", ""),
            boroughValue: type === 'all' ? data.total : (data.types[type] || 0)
        }));
    }


// popup design
    const popup = new mapboxgl.Popup({
      closeButton: true,
      offset: [0, -20],
      className: 'custom-popup'
    }).on('open', () => {
        document.querySelectorAll('.mapboxgl-popup').forEach(p => {
            p.removeAttribute('aria-hidden'); 
        });
    });

    let currentPopup = null;
    let closeTimer;

      
// left side filter
    const panelToggleBtn = document.querySelector('.panel-toggle-button');
      
    filterPanel.classList.add('expanded');
    panelToggleBtn.innerHTML = '«';  

    panelToggleBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      filterPanel.classList.toggle('expanded');
      panelToggleBtn.innerHTML = filterPanel.classList.contains('expanded') ? '«' : '»';
    });
      
      
// Adding London Boundary Data
    map.on('load', async () => {                
        
        map.addSource('london-boundary', {
            type: 'geojson',
            data: 'https://raw.githubusercontent.com/YULI61/visual_personal/main/London_boundary.geojson'
        });

        map.addLayer({
            id: 'london-boundary-layer',
            type: 'line',
            source: 'london-boundary',
            paint: {
                'line-color': '#FFD700',
                'line-width': 1,
                'line-opacity': 0.7
            }
        });


 // Adding Attraction Points Data 
    function loadPointData() {
        if (!map.getSource('attractions')) {
            map.addSource('attractions', {
                type: 'geojson',
                data: 'https://raw.githubusercontent.com/YULI61/visual_personal/main/london_tourism_4.geojson',
                cluster: true, 
                clusterMaxZoom: 14, 
                clusterRadius: 50  
            });
        }

      if (!map.getLayer('attractions-layer')) {
        map.addLayer({
          id: 'attractions-layer',
          type: 'circle',
          source: 'attractions',
          paint: {
            'circle-radius': 5,
            'circle-color': '#FFD700',
            'circle-opacity': 0.8
          }
        }, 'london-boundary-layer'); 
      }        
    }        
               
    map.on('sourcedata', (e) => {
        if (e.sourceId === 'attractions' && map.getSource('attractions').loaded()) {
            console.log(map.getSource('attractions')._data);
        }
    });
    
        
// Load data on initialisation
    map.once('load', () => {
      loadPointData();
      switchMode('point'); 
      initSlider();
    });
        
             
        
// Add attraction data and classification
      map.addSource('attractions', {
        type: 'geojson',
        data: 'https://raw.githubusercontent.com/YULI61/visual_personal/main/london_tourism_4.geojson'
      });

      map.addLayer({
        id: 'attractions-layer',
        type: 'circle',
        source: 'attractions',
        paint: {
          'circle-radius': 5,
          'circle-color': [
            'match', 
            ['get', 'type'],
            'museum', categoryColors.museum,
            'gallery', categoryColors.gallery,
            'other', categoryColors.other,
            'park', categoryColors.park,
            'historic', categoryColors.historic,
            'amenity', categoryColors.amenity,
            'attraction', categoryColors.attraction,
            '#CCCCCC' 
          ],
          'circle-opacity': 0.8,
          'circle-stroke-width': 0,
          'circle-stroke-color': '#FFFFFF'
              }
        })  

        
// Dynamically generated filter options
      const filterContent = document.querySelector('.filter-content');
      Object.entries(categoryColors).forEach(([type, color]) => {
        const option = document.createElement('div');
        option.className = 'filter-option';
        option.dataset.type = type;
        option.innerHTML = `
          <div class="color-dot" style="background: ${color}"></div>
          ${type.charAt(0).toUpperCase() + type.slice(1)}
        `;
        filterContent.appendChild(option);
      });

        document.querySelector('.filter-content').addEventListener('click', function(e) {
          const option = e.target.closest('.filter-option');
          if (!option) return;

          document.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');

          const selectedType = option.dataset.type;
          map.setFilter('attractions-layer', 
            selectedType === 'all' ? null : ['==', ['get', 'type'], selectedType]
          );
        });

        
// Hover to show pop-up window        
      let attractionPopup  = null; 
        
      map.on('mouseenter', 'attractions-layer', (e) => {
        if (mode !== 'point') return; 

        const props = e.features[0].properties;
        let html = `<h3 style="margin:0; color:${categoryColors[props.type] || '#FFF'}">${props.name}</h3>`;
        if (props.type) html += `<p style="color:#666">Type: ${props.type}</p>`;
        if (props.image) html += `<img src="${props.image}" style="max-width:200px; margin:10px 0">`;
        if (props.address) html += `<p>📍 ${props.address}</p>`;
        if (props.website) html += `<p>🌐 <a href="${props.website}" target="_blank" style="color:#1a73e8">Website</a></p>`;
        if (props.wikipedia) {
          const [lang, page] = props.wikipedia.split(':');
          html += `<p>📚 <a href="https://${lang}.wikipedia.org/wiki/${page.replace(/ /g, '_')}" target="_blank" style="color:#1a73e8">Wikipedia</a></p>`;
        }

        currentPopup = popup.setLngLat(e.lngLat).setHTML(html);
        currentPopup.addTo(map);
          
        setTimeout(() => {
            document.querySelectorAll('.mapboxgl-popup').forEach(popupElement => {
                popupElement.removeAttribute('aria-hidden');
            });
        }, 0); 
      });

      map.on('mouseleave', 'attractions-layer', () => {
        closeTimer = setTimeout(() => {
          currentPopup?.remove();
          currentPopup = null;
        }, 300);
      });

      document.addEventListener('mouseover', (e) => {
        if (e.target.closest('.mapboxgl-popup-content')) {
          clearTimeout(closeTimer);
        }
      });
       
     
//Area mode
    async function loadBoroughs() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/YULI61/visual_personal/main/London_borough_compressed.geojson');
            const geojson = await response.json();
          
            geojson.features.forEach((feature, index) => {
                feature.id = 'borough_${index + 1}'; 
            });
          
          
            if (!map.getSource('boroughs')) {
                map.addSource('boroughs', {
                    type: 'geojson',
                    data: geojson
                });
            }

            if (!map.getLayer('borough-fill')) {
                map.addLayer({
                    id: 'borough-fill',
                    type: 'fill',
                    source: 'boroughs',
                    paint: {
                        'fill-color': '#2A2A2A',
                        'fill-opacity': 0.8
                    }
                }, 'london-boundary-layer');
            }

            if (!map.getLayer('borough-border')) {
                map.addLayer({
                    id: 'borough-border',
                    type: 'line',
                    source: 'boroughs',
                    paint: {
                        'line-color': '#FFD700',
                        'line-width': 1
                    }
                });
            }

            if (!map.getLayer('borough-highlight')) {
                map.addLayer({
                    id: 'borough-highlight',
                    type: 'line',
                    source: 'boroughs',
                    paint: {
                        'line-color': '#FFD700',
                        'line-width': [
                            'case',
                            ['boolean', ['feature-state', 'hover'], false],
                            3,
                            0
                        ],
                        'line-opacity': 0.8
                    }
                }, 'london-boundary-layer');
            }

            map.setLayoutProperty('borough-fill', 'visibility', 'none');
            map.setLayoutProperty('borough-border', 'visibility', 'none');

        } catch (error) {
            console.error("Boroughs:", error);
        }
    }


    // Add interaction: hover highlighting
    let boroughPopup = null; 

    map.on('mousemove', 'borough-fill', (e) => {
        if (mode !== 'area') return;

        const boroughFeature = e.features[0];
        if (!boroughFeature || !boroughStatsData) return;

        const boroughName = boroughFeature.properties.name.trim();
        const stats = boroughStatsData.boroughs[boroughName] || { total: 0, types: {} };
        const selectedType = document.querySelector('.filter-option.active').dataset.type;

        const value = selectedType === 'all' ? stats.total : (stats.types[selectedType] || 0);

        if (boroughPopup && boroughPopup._lngLat.lng === e.lngLat.lng && boroughPopup._lngLat.lat === e.lngLat.lat) {
            return;
        }

        if (boroughPopup) {
            boroughPopup.remove();
        }

        boroughPopup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        })
            .setLngLat(e.lngLat)
            .setHTML(`
                <h4>${boroughName}</h4>
                <p>${selectedType === 'all' ? 'Total' : selectedType}: ${value}</p>
            `)
            .addTo(map);

        if (e.features[0].id) { 
            map.setFeatureState({
                source: 'boroughs',
                id: e.features[0].id 
            }, { 
                hover: true 
            });
        }

// legend
        const maxVal = Math.max(
            ...Object.values(boroughStatsData.boroughs)
                .map(b => selectedType === 'all' ? b.total : (b.types[selectedType] || 0))
        ) || 1; 

        const percent = Math.min(100, Math.max(0, (value / maxVal) * 100));
        document.querySelector('.legend-pointer').style.left = `${percent}%`;
    });

    map.on('mouseleave', 'borough-fill', () => {
        if (boroughPopup) {
            boroughPopup.remove();
            boroughPopup = null;
        }
    });

 
// Bar Chart design - top5 data
    function getTop5Data(type) {
        if (!boroughStatsData) return { labels: [], values: [] };

        const boroughs = Object.entries(boroughStatsData.boroughs)
            .map(([name, data]) => ({
                name: name.replace("London Borough of ", "")
                          .replace("Royal Borough of ", "")
                          .replace("City of ", ""),
                value: type === 'all' ? data.total : (data.types[type] || 0)
            }));

        const sorted = boroughs.sort((a, b) => b.value - a.value).slice(0, 5);

        return {
            labels: sorted.map(item => item.name),
            values: sorted.map(item => item.value)
        };
    }

    let chart; 

    async function initChart() {
        const ctx = document.getElementById('miniChart').getContext('2d');
        const initialData = getTop5Data('all');

        chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: initialData.labels,
                datasets: [{
                    data: initialData.values,
                    backgroundColor: ['#FFD700','#D84040', '#A31D1D', '#ECDCBF', '#F8F2DE'],  
                    borderColor: '#333',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    title: {
                        display: true,
                        text: "Top 5 Boroughs with Attractions", 
//                        color: "#FFD700", 
                        font: {
                            size: 14,
                            weight: 'bold',
                            family: 'Arial'
                        },
                        padding: 10
                    },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => `${ctx.parsed.y} attractions`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { 
//                            color: '#FFD700', 
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        },
                        grid: { 
//                            color: 'rgba(0,0,0,0.7)'  
                        }
                    },
                    x: {
                        ticks: { 
//                            color: '#FFFFFF', 
                            font: {
                                size: 12,
                                weight: 'bold'
                            }
                        },
                        grid: { 
//                            color: 'rgba(255,215,0,0.2)'  
                        }
                    }
                }
            }
        });
    }

    initChart();
    loadBoroughs();


//switchMode
    function switchMode(newMode) {
        
        document.querySelectorAll('.mode-toggle-button').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeButton = document.getElementById(newMode + 'Mode');
        activeButton.classList.add('active');
        
        mode = newMode;
        const selectedType = document.querySelector('.filter-option.active').dataset.type;
        
        const checkLayer = (layerId) => map.getLayer(layerId) !== undefined;
        
        filterPanel.style.display = newMode === 'cluster' ? 'none' : 'block';
        
        if (map.getLayer('unclustered-point')) {
                map.setLayoutProperty(
                    'unclustered-point', 
                    'visibility', 
                    newMode === 'cluster' ? 'visible' : 'none'
                );
        }

        if (mode === 'point') {
            if(checkLayer('attractions-layer')) map.setLayoutProperty('attractions-layer', 'visibility', 'visible');
            if(checkLayer('borough-fill')) map.setLayoutProperty('borough-fill', 'visibility', 'none');
            if(checkLayer('borough-border')) map.setLayoutProperty('borough-border', 'visibility', 'none');
            if(checkLayer('clusters')) map.setLayoutProperty('clusters', 'visibility', 'none');

        } else if (mode === 'area') {
            if(checkLayer('attractions-layer')) map.setLayoutProperty('attractions-layer', 'visibility', 'none');
            if(checkLayer('borough-fill')) map.setLayoutProperty('borough-fill', 'visibility', 'visible');
            if(checkLayer('borough-border')) map.setLayoutProperty('borough-border', 'visibility', 'visible');
            if(checkLayer('clusters')) map.setLayoutProperty('clusters', 'visibility', 'none');
            updateBoroughColors(selectedType);

        } else if (mode === 'cluster') {
            if(checkLayer('attractions-layer')) map.setLayoutProperty('attractions-layer', 'visibility', 'none');
            if(checkLayer('borough-fill')) map.setLayoutProperty('borough-fill', 'visibility', 'none');
            if(checkLayer('borough-border')) map.setLayoutProperty('borough-border', 'visibility', 'none');
            
            updateClusterVisualization();
            updateClusterDescription();
            document.getElementById('epsSlider').value = currentEPS;
        }

        map.dragPan.enable();
        map.scrollZoom.enable();
        
        document.getElementById('clusterControlsContainer').style.display = 
            newMode === 'cluster' ? 'flex' : 'none';

          const legend = document.getElementById('legend');
          const chartContainer = document.querySelector('.chart-container');
          if (newMode === 'area') {
            legend.style.display = 'block';
            chartContainer.style.display = 'block';
          } else {
            legend.style.display = 'none';
            chartContainer.style.display = 'none';
          }     
    }

      
//Borough Colors
    function updateBoroughColors(selectedType = 'all') {
        fetch('https://raw.githubusercontent.com/YULI61/visual_personal/main/borough_stats.json')
            .then(response => response.json())
            .then(boroughStatsData => {
                const boroughFeatures = map.getSource('boroughs')._data.features;

                const updatedFeatures = boroughFeatures.map(feature => {
                    const boroughName = feature.properties.name;
                    const stats = boroughStatsData.boroughs[boroughName] || { total: 0, types: {} };

                    let value = stats.total; 
                    if (selectedType !== 'all') {
                        value = stats.types[selectedType] || 0;
                    }

                    feature.properties.value = value;
                    return feature;
                });

                map.getSource('boroughs').setData({
                    type: 'FeatureCollection',
                    features: updatedFeatures
                });

                const maxVal = Math.max(...updatedFeatures.map(f => f.properties.value), 1);

                map.setPaintProperty('borough-fill', 'fill-color', [
                    'interpolate',
                    ['linear'],
                    ['get', 'value'],
                    0, '#1a1a1a',  
                    maxVal * 0.2, '#F8F2DE', 
                    maxVal * 0.4, '#ECDCBF', 
                    maxVal * 0.6, '#A31D1D', 
                    maxVal * 0.8, '#D84040', 
                    maxVal, '#ffff99' 
                ]);

                map.setPaintProperty('borough-fill', 'fill-opacity', 0.9);
            })
            .catch(console.error);
    }

      
//letf side filter content
    document.querySelector('.filter-content').addEventListener('click', function(e) {
        const option = e.target.closest('.filter-option');
        if (!option) return;

        document.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');

        const selectedType = option.dataset.type;

        map.setFilter('attractions-layer', 
            selectedType === 'all' ? null : ['==', ['get', 'type'], selectedType]
        );

        if (mode === 'area') {
            updateBoroughColors(selectedType);
        }
        
         if (mode === 'area') {
            const { labels, values } = getTop5Data(selectedType);
            chart.data.labels = labels;
            chart.data.datasets[0].data = values;
            chart.update();
          }
    });

    
//cluster mode
// Generate random colours
    function getRandomColor() {
        const colors = ['#FF3030', '#3498DB', '#FFD700', '#2ECC71', '#9B59B6', '#E67E22', '#1ABC9C'];
        return colors[Math.floor(Math.random() * colors.length)];
    }


// clustering visualisation function
    function updateClusterVisualization() {
        const eps = currentEPS;
        const clusterField = `cluster_${eps}m`;
        const source = map.getSource('attractions');
        if (!source || !source._data) {
            console.warn("Attractions data not loaded yet.");
            return;
        }

        ['clusters', 'cluster-count', 'unclustered-point'].forEach(layer => {
            if (map.getLayer(layer)) map.removeLayer(layer);
        });

        if (map.getSource('attractions')) {
            map.addLayer({
                id: 'clusters',
                type: 'circle',
                source: 'attractions',
                filter: ['all',
                         ['!=', ['get', clusterField], -1],  
                         ['!=', ['get', clusterField], null] 
                        ],
                paint: {
                    'circle-color': [
                        'rgb',
                        ['%', ['+', ['*', ['get', clusterField], 123], 456], 256],
                        ['%', ['+', ['*', ['get', clusterField], 456], 789], 256],
                        ['%', ['+', ['*', ['get', clusterField], 789], 123], 256]
                    ],
                    'circle-radius': [
                        'interpolate', ['linear'], ['zoom'],
                        10, 4,
                        16, 12
                    ],
                    'circle-opacity': 0.8
                },
                
                metadata: {
                    clusterField: clusterField 
                  }
                
            }, 'london-boundary-layer');

            map.addLayer({
                id: 'unclustered-point',
                type: 'circle',
                source: 'attractions',
                filter: ['==', ['get', clusterField], -1],
                paint: {
                    'circle-color': '#FFFFFF', 
                    'circle-radius': 4,
                    'circle-opacity': 0.5,
                    'circle-stroke-width': 0.5,
                    'circle-stroke-color': '#FFD700'
                }
            }, 'london-boundary-layer');
        }

        console.log("Querying cluster features...");
        updateClusterSelector(clusterField);
        setTimeout(() => {
            updateClusterSelector("cluster_" + currentEPS + "m");
        }, 300);       
    }


// cluster Selector     
    function updateClusterSelector(clusterField) {
        const features = map.querySourceFeatures('attractions');

        if (!features || features.length === 0) {
            console.warn("No cluster data found!");
            return;
        }

        const clusterIDs = [...new Set(features.map(f => f.properties[clusterField]).filter(id => id !== -1))].sort((a, b) => a - b);

        const selector = document.getElementById('clusterSelector');

        selector.innerHTML = `
            <option value="all">All Points</option>
            <option value="unclustered">Unclustered Points</option>
        `;

        if (clusterIDs.length === 0) {
            console.warn("No valid cluster IDs found!");
            return;
        }

        clusterIDs.forEach(id => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = `Cluster ${id}`;
            selector.appendChild(option);
        });

        console.log(`Generated ${clusterIDs.length} cluster ID options.`);
    }


// Cluster Description
    function updateClusterDescription() {
      const descriptions = {
        300: "An eps = 300m reveals detailed, walkable attraction clusters in central London, with dense groups in Westminster and South Bank, while suburban sites stay dispersed.",
        600: "Clusters expand, balancing detail and coverage. Tourist hubs (Westminster, South Bank) remain dense, while outer districts begin forming noticeable groups.",
        900: "Medium-scale clusters emerge, linking nearby attractions. Central London remains dominant, with suburban areas showing clearer attraction zones.",
        1200: "At 1200m, clusters expand, merging nearby attractions into broader regions. The Westminster-South Bank-Covent Garden area forms a single high-density cluster, while Kensington and Hyde Park integrate into a larger group. Suburban areas like Greenwich and Richmond develop distinct clusters.",
        1500: "At 1500m, clustering shifts focus to major tourist zones rather than individual neighborhoods. West End, City of London, and South Bank merge into one dominant cluster, while outer districts such as Stratford, Croydon, and Richmond show stronger connectivity."
      };

      const descElement = document.getElementById('clusterDescription');
      descElement.textContent = descriptions[currentEPS] || "Analyzing the current clustering range...";
    }      
      
      
// Slider design
    function initSlider() {
      const slider = document.getElementById('epsSlider');
      const ticksContainer = document.createElement('div');
      ticksContainer.className = 'slider-ticks';

      [300, 600, 900, 1200, 1500].forEach(value => {
        const tick = document.createElement('div');
        tick.className = 'slider-tick';
        tick.textContent = `${value}m`;
        ticksContainer.appendChild(tick);
      });

      slider.parentNode.insertBefore(ticksContainer, slider.nextSibling);

      let isDragging = false;

      slider.addEventListener('input', function() {
        if (!isDragging) {
          isDragging = true;
          this.style.cursor = 'grabbing';
        }

        const step = 300;
        let value = Math.round(this.value / step) * step;
        value = Math.max(300, Math.min(1500, value));
        this.value = value;

        currentEPS = value;
        if(mode === 'cluster') {
          updateClusterVisualization();
          updateClusterDescription();    
        }
      });

      slider.addEventListener('change', function() {
        isDragging = false;
        this.style.cursor = 'grab';
      });
        
    updateClusterDescription();        
    }
      
    document.getElementById('clusterSelector').addEventListener('change', function() {
        const selectedValue = this.value;
        const eps = currentEPS;
        const clusterField = `cluster_${eps}m`;
        const clustersExist = map.getLayer('clusters');
        const unclusteredExist = map.getLayer('unclustered-point');
        
          const activeClusterField = map.getLayer('clusters')?.metadata?.clusterField || clusterField        
          if (selectedValue === "all") {
            map.setFilter('clusters', null);
            map.setLayoutProperty('clusters', 'visibility', 'visible');
            map.setLayoutProperty('unclustered-point', 'visibility', 'visible');
          } else if (selectedValue === "unclustered") {
            map.setFilter('clusters', ['==', ['get', activeClusterField], -1]);
            map.setLayoutProperty('unclustered-point', 'visibility', 'visible');
          } else {
            map.setFilter('clusters', ['==', ['get', activeClusterField], parseInt(selectedValue)]);
            map.setLayoutProperty('unclustered-point', 'visibility', 'none');
          }
        });        

      
// Click function for clustered points
    map.on('click', ['clusters', 'unclustered-point'], function(e) {
      if (mode !== 'cluster') return;

      const clusterField = 'cluster_' + currentEPS + 'm';
      const clickedLayer = e.features[0].layer.id;

      if (clickedLayer === 'unclustered-point') {
        document.getElementById('clusterSelector').value = 'unclustered';
      } else {
        const clusterId = e.features[0].properties[clusterField];
        document.getElementById('clusterSelector').value = clusterId;
      }

      const event = new Event('change');
      document.getElementById('clusterSelector').dispatchEvent(event);
    });          
          
    map.on('click', function(e) {
      if (mode !== 'cluster') return;

      const features = map.queryRenderedFeatures(e.point, {
        layers: ['clusters', 'unclustered-point']
      });

      if (features.length === 0) {
        document.getElementById('clusterSelector').value = 'all';
        const event = new Event('change');
        document.getElementById('clusterSelector').dispatchEvent(event);
      }
    });     
      
      
    map.on('mouseenter', 'clusters', () => {
        map.getCanvas().style.cursor = 'pointer';
    });
    map.on('mouseleave', 'clusters', () => {
        map.getCanvas().style.cursor = '';
    });

      
    document.getElementById('clusterMode').addEventListener('click', () => switchMode('cluster'));
    document.getElementById('pointMode').addEventListener('click', () => switchMode('point'));
    document.getElementById('areaMode').addEventListener('click', () => switchMode('area'));
    
  });
  </script>
</body>
</html>